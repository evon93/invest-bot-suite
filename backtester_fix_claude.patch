diff --git a/backtest_initial.py b/backtest_initial.py
index 0000000..1111111 100644
--- a/backtest_initial.py
+++ b/backtest_initial.py
@@ -120,7 +120,11 @@ class SimpleBacktester:
             "CRYPTO_BTC": 0.08,
             "CRYPTO_ETH": 0.04,
             "BONDS": 0.28
         }
+        # Claude Opus 4 patch → control de rebalanceo
+        self.last_rebalance_date = None
+        self.rebalance_interval_days = 30
+        self.current_step = 0
 
@@ -140,6 +144,15 @@     def _rebalance(self, date: pd.Timestamp, risk_manager=None) -> None:
         """Ejecuta rebalanceo mensual aplicando reglas de riesgo."""
+        # Verificar precios válidos
+        current_prices = self.prices.loc[date]
+        valid_assets = [
+            a for a in self.prices.columns
+            if pd.notna(current_prices[a]) and current_prices[a] > 0
+        ]
+        if not valid_assets:
+            return
+
         current_weights = self._calculate_current_weights(date)
         nav = self.portfolio_value[-1]
@@ -175,7 +188,11 @@         for asset, delta in deltas.items():
             if abs(delta) < 0.01:  # Umbral mínimo 1 %
                 continue
-            target_value = self.target_weights.get(asset, 0) * nav
-            current_shares = self.positions.get(asset, 0)
-            target_shares = target_value / self.prices.loc[date, asset]
+            if asset not in valid_assets:
+                continue
+            target_value = self.target_weights.get(asset, 0) * nav
+            current_shares = self.positions.get(asset, 0)
+            price = self.prices.loc[date, asset]
+            target_shares = target_value / price if price > 0 else 0
             shares_delta = target_shares - current_shares
             if shares_delta != 0:
                 self.positions[asset] = target_shares
                 self.trades.append({
@@ -185,6 +202,8 @@                 self.trades.append({
                     "value": shares_delta * self.prices.loc[date, asset]
                 })
+        self.last_rebalance_date = date
+
@@ -200,7 +219,12 @@     def run(self, risk_manager=None) -> pd.DataFrame:
             total_value = 0
             for asset, shares in self.positions.items():
-                total_value += shares * self.prices.loc[date, asset]
+                price = self.prices.loc[date, asset]
+                if pd.notna(price) and price > 0:
+                    total_value += shares * price
+            if total_value == 0 and portfolio_values:
+                total_value = portfolio_values[-1]["value"]
 
             portfolio_values.append({
                 "date": date,
@@ -210,7 +234,9 @@             portfolio_values.append({
                 "weights": self._calculate_current_weights(date)
             })
-            if date.day == 1 and date != first_date:
+            days_since_last = (date - self.last_rebalance_date).days if self.last_rebalance_date else 30
+            if days_since_last >= self.rebalance_interval_days:
                 self._rebalance(date, risk_manager)
 
         return pd.DataFrame(portfolio_values)
@@ -230,8 +256,13 @@ def calculate_metrics(portfolio_df: pd.DataFrame, benchmark_return: float = 0.08
-    rolling_max = portfolio_df["value"].expanding().max()
-    drawdown = (portfolio_df["value"] / rolling_max - 1)
-    max_dd = drawdown.min()
+    values = portfolio_df["value"].replace(0, np.nan).ffill()
+    rolling_max = values.expanding().max()
+    drawdown = values / rolling_max - 1
+    max_dd = drawdown.min() if not drawdown.empty else 0
 
-    sharpe = returns.mean() / returns.std() * np.sqrt(252)
+    sharpe = (
+        returns.mean() / returns.std() * np.sqrt(252)
+        if returns.std() > 0
+        else 0
+    )
 
     tracking_error = cagr - benchmark_return


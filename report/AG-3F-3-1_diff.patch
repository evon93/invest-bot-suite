diff --git a/engine/bus_workers.py b/engine/bus_workers.py
index eb8e906..482d874 100644
--- a/engine/bus_workers.py
+++ b/engine/bus_workers.py
@@ -19,7 +19,7 @@ import logging
 from bus import InMemoryBus, BusEnvelope
 from contracts.events_v1 import OrderIntentV1, RiskDecisionV1, ExecutionReportV1
 from state.position_store_sqlite import PositionStoreSQLite
-from engine.exchange_adapter import ExchangeAdapter, PaperExchangeAdapter, ExecutionContext
+from engine.exchange_adapter import ExchangeAdapter, PaperExchangeAdapter, ExecutionContext, TransientNetworkError
 from engine.retry_policy import RetryPolicy, retry_call, RetryExhaustedError
 from engine.idempotency import IdempotencyStore, InMemoryIdempotencyStore
 
@@ -309,9 +309,9 @@ class ExecWorker:
         # Execute with retry if policy configured
         try:
             if self._retry_policy:
-                # Retry only on transient network errors
+                # Retry only on transient network errors (including SimulatedRealtimeAdapter's TransientNetworkError)
                 def is_retryable(e):
-                    return isinstance(e, (ConnectionError, TimeoutError, OSError))
+                    return isinstance(e, (ConnectionError, TimeoutError, OSError, TransientNetworkError))
                 
                 report, attempts = retry_call(
                     do_submit,
diff --git a/engine/exchange_adapter.py b/engine/exchange_adapter.py
index 9485808..90f42b9 100644
--- a/engine/exchange_adapter.py
+++ b/engine/exchange_adapter.py
@@ -161,3 +161,91 @@ class StubNetworkExchangeAdapter:
         report.extra["simulated_latency_steps"] = self.latency_steps
         
         return report
+
+
+class TransientNetworkError(Exception):
+    """Simulated transient network error for testing retry logic."""
+    pass
+
+
+@dataclass
+class SimulatedRealtimeAdapter:
+    """
+    Real-ish adapter simulating exchange conditions:
+    - Configurable latencies (via sleep_fn, no real sleep in tests)
+    - Deterministic transient failures (hash-based, 1-of-N)
+    - Realistic responses (IDs, intermediate states)
+    
+    Gated: only activated with INVESTBOT_EXCHANGE_KIND=realish or --exchange realish
+    
+    This adapter does NOT require secrets - it's a local simulation.
+    """
+    failure_rate_1_in_n: int = 10  # 1 de cada 10 falla transitoriamente
+    base_latency_ms: int = 50
+    max_latency_ms: int = 500
+    slippage_bps: float = 10.0
+    fee_bps: float = 15.0
+    sleep_fn: Callable[[int], None] = field(default_factory=lambda: lambda ms: None)
+    _failure_count: int = field(default=0, init=False)
+    
+    def _should_fail_transient(self, op_key: str) -> bool:
+        """
+        Deterministic failure based on hash of op_key.
+        Returns True if this operation should fail transiently.
+        """
+        import hashlib
+        hash_int = int(hashlib.sha256(op_key.encode()).hexdigest()[:8], 16)
+        return (hash_int % self.failure_rate_1_in_n) == 0
+    
+    def _compute_latency_ms(self, op_key: str) -> int:
+        """
+        Compute deterministic latency based on hash of op_key.
+        Returns latency in milliseconds.
+        """
+        import hashlib
+        hash_int = int(hashlib.sha256(op_key.encode()).hexdigest()[8:16], 16)
+        # Range: base_latency_ms to max_latency_ms
+        latency_range = self.max_latency_ms - self.base_latency_ms
+        latency = self.base_latency_ms + (hash_int % max(1, latency_range))
+        return latency
+    
+    def submit(
+        self,
+        intent: OrderIntentV1,
+        decision: RiskDecisionV1,
+        context: ExecutionContext,
+        report_event_id: str,
+        extra_meta: Optional[Dict[str, Any]] = None
+    ) -> ExecutionReportV1:
+        """
+        Submit with simulated real-world conditions.
+        
+        May raise TransientNetworkError for testing retry logic.
+        """
+        meta = extra_meta or {}
+        
+        # Generate op_key for deterministic behavior
+        op_key = f"realish:{decision.ref_order_event_id}:{report_event_id}"
+        
+        # Simulate transient failure (deterministic)
+        if self._should_fail_transient(op_key):
+            self._failure_count += 1
+            raise TransientNetworkError(
+                f"Simulated transient failure for op_key hash (attempt may be retried)"
+            )
+        
+        # Simulate latency (via injectable sleep_fn - no-op in tests)
+        latency_ms = self._compute_latency_ms(op_key)
+        self.sleep_fn(latency_ms)
+        
+        # Delegate core logic to Paper adapter with higher slippage/fees
+        paper = PaperExchangeAdapter(slippage_bps=self.slippage_bps, fee_bps=self.fee_bps)
+        report = paper.submit(intent, decision, context, report_event_id, extra_meta)
+        
+        # Enrich with realish metadata
+        report.latency_ms = float(latency_ms)
+        report.extra["adapter"] = "SimulatedRealtimeAdapter"
+        report.extra["simulated_latency_ms"] = latency_ms
+        report.extra["failure_rate_1_in_n"] = self.failure_rate_1_in_n
+        
+        return report
diff --git a/engine/runtime_config.py b/engine/runtime_config.py
index 32b397b..a207d64 100644
--- a/engine/runtime_config.py
+++ b/engine/runtime_config.py
@@ -98,8 +98,8 @@ class RuntimeConfig:
         mode_clock = mode_clock.lower().strip()
         exchange_kind = exchange_kind.lower().strip()
         
-        # Paper and stub exchanges don't require secrets
-        if exchange_kind in ("paper", "stub"):
+        # Paper, stub, and realish (local simulation) don't require secrets
+        if exchange_kind in ("paper", "stub", "realish"):
             return
         
         # For non-paper exchanges, check if secrets are required
diff --git a/tools/run_live_3E.py b/tools/run_live_3E.py
index 40f4080..e18437c 100644
--- a/tools/run_live_3E.py
+++ b/tools/run_live_3E.py
@@ -33,7 +33,7 @@ from bus import InMemoryBus
 from engine.loop_stepper import LoopStepper
 from engine.run_metrics_3D5 import collect_metrics_from_jsonl
 from engine.time_provider import SimulatedTimeProvider, RealTimeProvider
-from engine.exchange_adapter import PaperExchangeAdapter, StubNetworkExchangeAdapter
+from engine.exchange_adapter import PaperExchangeAdapter, StubNetworkExchangeAdapter, SimulatedRealtimeAdapter
 from engine.runtime_config import RuntimeConfig
 from risk_rules_loader import load_risk_rules
 
@@ -90,7 +90,7 @@ def main():
     
     # 3E Features
     parser.add_argument("--clock", choices=["simulated", "real"], default="simulated", help="Time provider mode")
-    parser.add_argument("--exchange", choices=["paper", "stub"], default="paper", help="Exchange adapter mode")
+    parser.add_argument("--exchange", choices=["paper", "stub", "realish"], default="paper", help="Exchange adapter mode")
     parser.add_argument("--latency-steps", type=int, default=1, help="Latency steps for stub exchange")
     
     args = parser.parse_args()
@@ -118,7 +118,9 @@ def main():
         time_provider = SimulatedTimeProvider(seed=args.seed)
         
     # 2. Setup ExchangeAdapter
-    if args.exchange == "stub":
+    if args.exchange == "realish":
+        exchange_adapter = SimulatedRealtimeAdapter()
+    elif args.exchange == "stub":
         exchange_adapter = StubNetworkExchangeAdapter(latency_steps=args.latency_steps)
     else:
         exchange_adapter = PaperExchangeAdapter()

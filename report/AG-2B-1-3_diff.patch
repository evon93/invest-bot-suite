diff --git a/backtest_initial.py b/backtest_initial.py
index 7751077..0f4838d 100644
--- a/backtest_initial.py
+++ b/backtest_initial.py
@@ -9,6 +9,7 @@ import logging
 import os
 from datetime import datetime
 from pathlib import Path
+from collections import defaultdict
 from typing import Dict, List, Union
 
 import numpy as np
@@ -80,6 +81,8 @@ class SimpleBacktester:
         self.portfolio_value: List[float] = [initial_capital]
         self.positions: Dict[str, float] = {c: 0.0 for c in self.prices.columns}
         self.trades: List[Dict] = []
+        self.closed_trades: List[Dict] = []  # Trades cerrados con PnL
+        self._avg_cost: Dict[str, float] = defaultdict(float)  # Coste medio por asset
         
         # Precios efectivos (├║ltimo precio v├ílido > 0 visto)
         self.last_valid_prices: Dict[str, float] = {}
@@ -147,7 +150,41 @@ class SimpleBacktester:
 
             target_val = self.target_weights.get(asset, 0) * nav
             target_shares = target_val / price
-            shares_delta = target_shares - self.positions.get(asset, 0)
+            prev_shares = self.positions.get(asset, 0)
+            shares_delta = target_shares - prev_shares
+            
+            # --- Tracking de avg_cost y closed_trades (long-only) ---
+            # Nota: Este sistema asume posiciones long-only (shares >= 0).
+            # Short selling no est├í soportado actualmente.
+            
+            if shares_delta > 0:
+                # Compra: apertura o scale-in
+                if prev_shares == 0:
+                    # Nueva posici├│n: avg_cost = precio de entrada
+                    self._avg_cost[asset] = price
+                else:
+                    # Scale-in: actualizar avg_cost ponderado
+                    total_cost = self._avg_cost[asset] * prev_shares + price * shares_delta
+                    self._avg_cost[asset] = total_cost / target_shares
+                    
+            elif shares_delta < 0 and prev_shares > 0:
+                # Venta: cierre parcial o total
+                closed_qty = min(abs(shares_delta), prev_shares)
+                entry_cost = self._avg_cost[asset]
+                realized_pnl = (price - entry_cost) * closed_qty
+                
+                self.closed_trades.append({
+                    "date": date,
+                    "asset": asset,
+                    "qty": closed_qty,
+                    "entry_cost": entry_cost,
+                    "exit_price": price,
+                    "realized_pnl": realized_pnl,
+                })
+                
+                # Si cierre total, reset avg_cost
+                if target_shares == 0:
+                    self._avg_cost[asset] = 0.0
             
             # Registrar trade si hay cambio O si es necesario para cumplir requisitos de frecuencia (logging)
             # Para single asset 100%, delta suele ser 0, pero el test espera "actividad".
